# coding: utf-8

"""
    Save.TV API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class RecordsDeleteApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def records_delete(self, **kwargs):  # noqa: E501
        """Deletes the records that match the given filter.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.records_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool adfreeavailable: Determines wether the ad cut list is available.
        :param list[int] channels: A comma-separated list of TV channel identifiers.
        :param list[int] dayofweeks: Selects only telecast whose start date matches the given day of weeks. The start date comparison is based on local time.    Values:    0 = Sunday    1 = Monday    2 = Tuesday    3 = Wednesday    4 = Thursday    5 = Friday    6 = Saturday
        :param str exacttitle: Selects only telecasts whose title matches exactly (but case insensitive) the given value.
        :param list[str] exacttitles: Selects only telecasts whose title matches exactly (but case insensitive) one of the given values.    When the parameter \"exactTitle\" is given too, the value of this parameter is ignored.    The titles are separated by a comma. Commas inside a title are escaped with \"\\,\" (1 back slash, 1 commma).    Example:    Title 1: Tatort    Title 2: Im Himmel, unter der Erde    Value: Tatort,Im Himmel\\, unter der Erde
        :param list[int] excludedtelecastids: A comma-separated list of telecast identifiers that will be ignored even if the other filter criterias would match these telecasts.
        :param list[int] excludedtvstations: A comma-separated list of TV station identifiers that must not match.
        :param bool excluderepeatedbroadcasts:
        :param list[str] fields: Selects the fields that will be transmitted in the response. The field names are comma-separated, case-insensitive and will be trimmed.    The field \"telecastid\" is always transmitted.    _The allowed field values:_    adfreeavailable,    adfreelength,    channels,    channels.id,    channels.name,    createdate,    defect.adcut.availablelength,    defect.adcut.expectedlength,    defect.adcut.istelecastendset,    defect.adcut.istelecaststartset,    defect.encoding.followuptime.availablelength,    defect.encoding.followuptime.expectedlength,    defect.encoding.leadtime.availablelength,    defect.encoding.leadtime.expectedlength,    defect.encoding.telecast.availablelength,    defect.encoding.telecast.expectedlength,    enddate,    formats,    formats.cutvideosize,    formats.recordformat.id,    formats.recordformat.name,    formats.recordstate.id,    formats.recordstate.name,    formats.recordstatemessage,    formats.retentiondate,    formats.uncutvideosize,    isadcutenabled,    playlists.id,    playlists.name,    resumepositions,    resumepositions.adfree,    resumepositions.default,    startdate,    tags.key,    tags.value,    telecast,    telecast.commentator,    telecast.country,    telecast.description,    telecast.director,    telecast.enddate,    telecast.episode,    telecast.hasmoved,    telecast.id,    telecast.imageurl100,    telecast.imageurl250,    telecast.imageurl500,    telecast.interpret,    telecast.isblackwhite,    telecast.ishighlight,    telecast.isomitted,    telecast.moderator,    telecast.rating,    telecast.roles,    telecast.roles.rolename,    telecast.roles.starid,    telecast.roles.starname,    telecast.slug,    telecast.startdate,    telecast.subject,    telecast.subtitle,    telecast.title,    telecast.tvcategory.id,    telecast.tvcategory.name,    telecast.tvstation.id,    telecast.tvstation.isrecordable,    telecast.tvstation.largelogourl,    telecast.tvstation.name,    telecast.tvstation.smalllogourl,    telecast.tvsubcategory.id,    telecast.tvsubcategory.name,    telecast.updatedate,    telecast.voluntaryselfregulationofthemovieindustry,    telecast.year,    telecastid,    updatedate
        :param list[int] fsk: Selects only telecasts whose fsk matches the given value.    Values:    0 = Includes all ages from 0 to 5.    6 = Includes all ages from 6 to 11.    12 = Includes all ages from 12 to 15.    16 = Includes all ages from 16 to 17.    18 = Includes all ages from 18 and above.
        :param bool ishighlight: Determines whether the telecast must be an highlight or not.
        :param datetime lastupdatedate: Selects only records that was updated (finished, ad free available, changed record dates, ...) / created after the given date.    Date format: 2015-03-20 17:45:00Z
        :param int limit: Sets the maximum number of items in result set.    The default value: 50.    The maximum allowed value: 5000.
        :param datetime maxenddate: The maximum end date of the telecast.    Date format: 2015-03-20 17:45:00Z
        :param datetime maxstartdate: The maximum start date of the telecast.    Date format: 2015-03-20 17:45:00Z
        :param str maxstarttime: The maximum start time of the telecast. The time is interpreted as local time. The given value is inclusive.    Time format: 17:30
        :param datetime minenddate: The minimum end date of the telecast.    Date format: 2015-03-20 17:45:00Z
        :param datetime minstartdate: The minimum start date of the telecast.    Date format: 2015-03-20 17:45:00Z
        :param str minstarttime: The minimum start time of the telecast. The time is interpreted as local time. The given value is inclusive.    Time format: 17:30
        :param bool nopagingheader: By default, the response object is a plain list of items and the paging metadata is put into the header.    Example header:     X-Total-Count: 403    X-Paging-Offset: 0    X-Paging-Limit: 20    When set to true, the response object is a complex object that contains the paging meta data and the items in 2 separate properties. The header does not contain additional values
        :param int offset: Sets the number of data items that are skipped in the result set.    The default value: 0.
        :param str q: The search text used for a text search.
        :param list[int] recordformats: A comma-separated list of record formats. Selects only telecasts that are available in the given formats.    Values:    4 = Mobile    5 = SD    6 = HD
        :param list[int] recordstates: A comma-separated list of record states.    Values:    1 = The user has requested the format.    2 = The format was successfully recorded or the recording process failed.    3 = The format was recorded and encoded successful and the user can download the format.    4 = The recording or encoding process produced errors. The user cannot download the format.    5 = The user has deleted the format.
        :param bool removedeletedtelecasts: When set, deleted records are removed from result set.    The default value is true.
        :param int searchtextscope: The scope defines the kind of the text search.    The default value is: 1    Values:     1 = search in all texts    2 = search in title and subtitle
        :param list[object] sort: Sets the sort properties. The values are comma-separated. To sort ascending add a \"+\" before the sort property, to sort descending add a \"-\" before the sort property.    When omitted, a default sorting is used.    Example: sort=+prop1,-prop2    Sorts first by prop1 ascending then by prop2 descending.    Allowed sort properties:    category    episode    random    startdate    subcategory    subtitle    title    tvstationposition    year    Default sorting:    +startdate
        :param list[int] starids: A comma-separated list of star identifiers.
        :param list[str] tags: A comma-separated list of tag keys.    Values:    record:guard = The record was adjusted by the guard.    record:manual = The record was created manually.    record:resume:0 = The record was partially seen and can be resumed at the last position. The record was seen with ad.    record:resume:1 = The record was partially seen and can be resumed at the last position. The record was seen without ad.    record:seen = The record was seen / downloaded.
        :param list[int] telecastids: A comma-separated list of telecast identifiers.
        :param int timeblock: A time block selects telecasts of one time range.    Values    1 = telecasts that start between 06:00 and 12:00, contains also the telecast that runs at 06:00    2 = telecasts that start between 06:00 and 12:00    3 = telecasts that start between 12:00 and 18:00    4 = telecasts that start between 18:00 and 00:00    5 = telecasts that start between 00:00 and 06:00    6 = telecasts that are running currently, one telecast per TV station    7 = telecasts that start after the currently running telecasts, one telecast per TV station    8 = telecasts that start between 20:15 and 20:30    9 = telecasts that start after 22:15
        :param list[int] timeblocks: A list of time blocks that selects telecasts of one time range.    Values:    1 = telecasts that start between 06:00 and 12:00, contains also the telecast that runs at 06:00    2 = telecasts that start between 06:00 and 12:00    3 = telecasts that start between 12:00 and 18:00    4 = telecasts that start between 18:00 and 00:00    5 = telecasts that start between 00:00 and 06:00    6 = telecasts that are running currently, one telecast per TV station    7 = telecasts that start after the currently running telecasts, one telecast per TV station    8 = telecasts that start between 20:15 and 20:30    9 = telecasts that start after 22:15    6 + 7 must be used exclusively, all others can be combined.
        :param list[int] tvcategories: A comma-separated list of TV category identifiers.
        :param list[int] tvstations: A comma-separated list of TV station identifiers.
        :param list[int] tvsubcategories: A comma-separated list of TV sub category identifiers.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.records_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.records_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def records_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Deletes the records that match the given filter.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.records_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool adfreeavailable: Determines wether the ad cut list is available.
        :param list[int] channels: A comma-separated list of TV channel identifiers.
        :param list[int] dayofweeks: Selects only telecast whose start date matches the given day of weeks. The start date comparison is based on local time.    Values:    0 = Sunday    1 = Monday    2 = Tuesday    3 = Wednesday    4 = Thursday    5 = Friday    6 = Saturday
        :param str exacttitle: Selects only telecasts whose title matches exactly (but case insensitive) the given value.
        :param list[str] exacttitles: Selects only telecasts whose title matches exactly (but case insensitive) one of the given values.    When the parameter \"exactTitle\" is given too, the value of this parameter is ignored.    The titles are separated by a comma. Commas inside a title are escaped with \"\\,\" (1 back slash, 1 commma).    Example:    Title 1: Tatort    Title 2: Im Himmel, unter der Erde    Value: Tatort,Im Himmel\\, unter der Erde
        :param list[int] excludedtelecastids: A comma-separated list of telecast identifiers that will be ignored even if the other filter criterias would match these telecasts.
        :param list[int] excludedtvstations: A comma-separated list of TV station identifiers that must not match.
        :param bool excluderepeatedbroadcasts:
        :param list[str] fields: Selects the fields that will be transmitted in the response. The field names are comma-separated, case-insensitive and will be trimmed.    The field \"telecastid\" is always transmitted.    _The allowed field values:_    adfreeavailable,    adfreelength,    channels,    channels.id,    channels.name,    createdate,    defect.adcut.availablelength,    defect.adcut.expectedlength,    defect.adcut.istelecastendset,    defect.adcut.istelecaststartset,    defect.encoding.followuptime.availablelength,    defect.encoding.followuptime.expectedlength,    defect.encoding.leadtime.availablelength,    defect.encoding.leadtime.expectedlength,    defect.encoding.telecast.availablelength,    defect.encoding.telecast.expectedlength,    enddate,    formats,    formats.cutvideosize,    formats.recordformat.id,    formats.recordformat.name,    formats.recordstate.id,    formats.recordstate.name,    formats.recordstatemessage,    formats.retentiondate,    formats.uncutvideosize,    isadcutenabled,    playlists.id,    playlists.name,    resumepositions,    resumepositions.adfree,    resumepositions.default,    startdate,    tags.key,    tags.value,    telecast,    telecast.commentator,    telecast.country,    telecast.description,    telecast.director,    telecast.enddate,    telecast.episode,    telecast.hasmoved,    telecast.id,    telecast.imageurl100,    telecast.imageurl250,    telecast.imageurl500,    telecast.interpret,    telecast.isblackwhite,    telecast.ishighlight,    telecast.isomitted,    telecast.moderator,    telecast.rating,    telecast.roles,    telecast.roles.rolename,    telecast.roles.starid,    telecast.roles.starname,    telecast.slug,    telecast.startdate,    telecast.subject,    telecast.subtitle,    telecast.title,    telecast.tvcategory.id,    telecast.tvcategory.name,    telecast.tvstation.id,    telecast.tvstation.isrecordable,    telecast.tvstation.largelogourl,    telecast.tvstation.name,    telecast.tvstation.smalllogourl,    telecast.tvsubcategory.id,    telecast.tvsubcategory.name,    telecast.updatedate,    telecast.voluntaryselfregulationofthemovieindustry,    telecast.year,    telecastid,    updatedate
        :param list[int] fsk: Selects only telecasts whose fsk matches the given value.    Values:    0 = Includes all ages from 0 to 5.    6 = Includes all ages from 6 to 11.    12 = Includes all ages from 12 to 15.    16 = Includes all ages from 16 to 17.    18 = Includes all ages from 18 and above.
        :param bool ishighlight: Determines whether the telecast must be an highlight or not.
        :param datetime lastupdatedate: Selects only records that was updated (finished, ad free available, changed record dates, ...) / created after the given date.    Date format: 2015-03-20 17:45:00Z
        :param int limit: Sets the maximum number of items in result set.    The default value: 50.    The maximum allowed value: 5000.
        :param datetime maxenddate: The maximum end date of the telecast.    Date format: 2015-03-20 17:45:00Z
        :param datetime maxstartdate: The maximum start date of the telecast.    Date format: 2015-03-20 17:45:00Z
        :param str maxstarttime: The maximum start time of the telecast. The time is interpreted as local time. The given value is inclusive.    Time format: 17:30
        :param datetime minenddate: The minimum end date of the telecast.    Date format: 2015-03-20 17:45:00Z
        :param datetime minstartdate: The minimum start date of the telecast.    Date format: 2015-03-20 17:45:00Z
        :param str minstarttime: The minimum start time of the telecast. The time is interpreted as local time. The given value is inclusive.    Time format: 17:30
        :param bool nopagingheader: By default, the response object is a plain list of items and the paging metadata is put into the header.    Example header:     X-Total-Count: 403    X-Paging-Offset: 0    X-Paging-Limit: 20    When set to true, the response object is a complex object that contains the paging meta data and the items in 2 separate properties. The header does not contain additional values
        :param int offset: Sets the number of data items that are skipped in the result set.    The default value: 0.
        :param str q: The search text used for a text search.
        :param list[int] recordformats: A comma-separated list of record formats. Selects only telecasts that are available in the given formats.    Values:    4 = Mobile    5 = SD    6 = HD
        :param list[int] recordstates: A comma-separated list of record states.    Values:    1 = The user has requested the format.    2 = The format was successfully recorded or the recording process failed.    3 = The format was recorded and encoded successful and the user can download the format.    4 = The recording or encoding process produced errors. The user cannot download the format.    5 = The user has deleted the format.
        :param bool removedeletedtelecasts: When set, deleted records are removed from result set.    The default value is true.
        :param int searchtextscope: The scope defines the kind of the text search.    The default value is: 1    Values:     1 = search in all texts    2 = search in title and subtitle
        :param list[object] sort: Sets the sort properties. The values are comma-separated. To sort ascending add a \"+\" before the sort property, to sort descending add a \"-\" before the sort property.    When omitted, a default sorting is used.    Example: sort=+prop1,-prop2    Sorts first by prop1 ascending then by prop2 descending.    Allowed sort properties:    category    episode    random    startdate    subcategory    subtitle    title    tvstationposition    year    Default sorting:    +startdate
        :param list[int] starids: A comma-separated list of star identifiers.
        :param list[str] tags: A comma-separated list of tag keys.    Values:    record:guard = The record was adjusted by the guard.    record:manual = The record was created manually.    record:resume:0 = The record was partially seen and can be resumed at the last position. The record was seen with ad.    record:resume:1 = The record was partially seen and can be resumed at the last position. The record was seen without ad.    record:seen = The record was seen / downloaded.
        :param list[int] telecastids: A comma-separated list of telecast identifiers.
        :param int timeblock: A time block selects telecasts of one time range.    Values    1 = telecasts that start between 06:00 and 12:00, contains also the telecast that runs at 06:00    2 = telecasts that start between 06:00 and 12:00    3 = telecasts that start between 12:00 and 18:00    4 = telecasts that start between 18:00 and 00:00    5 = telecasts that start between 00:00 and 06:00    6 = telecasts that are running currently, one telecast per TV station    7 = telecasts that start after the currently running telecasts, one telecast per TV station    8 = telecasts that start between 20:15 and 20:30    9 = telecasts that start after 22:15
        :param list[int] timeblocks: A list of time blocks that selects telecasts of one time range.    Values:    1 = telecasts that start between 06:00 and 12:00, contains also the telecast that runs at 06:00    2 = telecasts that start between 06:00 and 12:00    3 = telecasts that start between 12:00 and 18:00    4 = telecasts that start between 18:00 and 00:00    5 = telecasts that start between 00:00 and 06:00    6 = telecasts that are running currently, one telecast per TV station    7 = telecasts that start after the currently running telecasts, one telecast per TV station    8 = telecasts that start between 20:15 and 20:30    9 = telecasts that start after 22:15    6 + 7 must be used exclusively, all others can be combined.
        :param list[int] tvcategories: A comma-separated list of TV category identifiers.
        :param list[int] tvstations: A comma-separated list of TV station identifiers.
        :param list[int] tvsubcategories: A comma-separated list of TV sub category identifiers.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['adfreeavailable', 'channels', 'dayofweeks', 'exacttitle', 'exacttitles', 'excludedtelecastids', 'excludedtvstations', 'excluderepeatedbroadcasts', 'fields', 'fsk', 'ishighlight', 'lastupdatedate', 'limit', 'maxenddate', 'maxstartdate', 'maxstarttime', 'minenddate', 'minstartdate', 'minstarttime', 'nopagingheader', 'offset', 'q', 'recordformats', 'recordstates', 'removedeletedtelecasts', 'searchtextscope', 'sort', 'starids', 'tags', 'telecastids', 'timeblock', 'timeblocks', 'tvcategories', 'tvstations', 'tvsubcategories']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method records_delete" % key
                )
            params[key] = val
        del params['kwargs']

        if ('maxstarttime' in params and
                len(params['maxstarttime']) > 5):
            raise ValueError("Invalid value for parameter `maxstarttime` when calling `records_delete`, length must be less than or equal to `5`")  # noqa: E501
        if ('minstarttime' in params and
                len(params['minstarttime']) > 5):
            raise ValueError("Invalid value for parameter `minstarttime` when calling `records_delete`, length must be less than or equal to `5`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'adfreeavailable' in params:
            query_params.append(('adfreeavailable', params['adfreeavailable']))  # noqa: E501
        if 'channels' in params:
            query_params.append(('channels', params['channels']))  # noqa: E501
            collection_formats['channels'] = 'multi'  # noqa: E501
        if 'dayofweeks' in params:
            query_params.append(('dayofweeks', params['dayofweeks']))  # noqa: E501
            collection_formats['dayofweeks'] = 'multi'  # noqa: E501
        if 'exacttitle' in params:
            query_params.append(('exacttitle', params['exacttitle']))  # noqa: E501
        if 'exacttitles' in params:
            query_params.append(('exacttitles', params['exacttitles']))  # noqa: E501
            collection_formats['exacttitles'] = 'multi'  # noqa: E501
        if 'excludedtelecastids' in params:
            query_params.append(('excludedtelecastids', params['excludedtelecastids']))  # noqa: E501
            collection_formats['excludedtelecastids'] = 'multi'  # noqa: E501
        if 'excludedtvstations' in params:
            query_params.append(('excludedtvstations', params['excludedtvstations']))  # noqa: E501
            collection_formats['excludedtvstations'] = 'multi'  # noqa: E501
        if 'excluderepeatedbroadcasts' in params:
            query_params.append(('excluderepeatedbroadcasts', params['excluderepeatedbroadcasts']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'fsk' in params:
            query_params.append(('fsk', params['fsk']))  # noqa: E501
            collection_formats['fsk'] = 'multi'  # noqa: E501
        if 'ishighlight' in params:
            query_params.append(('ishighlight', params['ishighlight']))  # noqa: E501
        if 'lastupdatedate' in params:
            query_params.append(('lastupdatedate', params['lastupdatedate']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'maxenddate' in params:
            query_params.append(('maxenddate', params['maxenddate']))  # noqa: E501
        if 'maxstartdate' in params:
            query_params.append(('maxstartdate', params['maxstartdate']))  # noqa: E501
        if 'maxstarttime' in params:
            query_params.append(('maxstarttime', params['maxstarttime']))  # noqa: E501
        if 'minenddate' in params:
            query_params.append(('minenddate', params['minenddate']))  # noqa: E501
        if 'minstartdate' in params:
            query_params.append(('minstartdate', params['minstartdate']))  # noqa: E501
        if 'minstarttime' in params:
            query_params.append(('minstarttime', params['minstarttime']))  # noqa: E501
        if 'nopagingheader' in params:
            query_params.append(('nopagingheader', params['nopagingheader']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'recordformats' in params:
            query_params.append(('recordformats', params['recordformats']))  # noqa: E501
            collection_formats['recordformats'] = 'multi'  # noqa: E501
        if 'recordstates' in params:
            query_params.append(('recordstates', params['recordstates']))  # noqa: E501
            collection_formats['recordstates'] = 'multi'  # noqa: E501
        if 'removedeletedtelecasts' in params:
            query_params.append(('removedeletedtelecasts', params['removedeletedtelecasts']))  # noqa: E501
        if 'searchtextscope' in params:
            query_params.append(('searchtextscope', params['searchtextscope']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501
        if 'starids' in params:
            query_params.append(('starids', params['starids']))  # noqa: E501
            collection_formats['starids'] = 'multi'  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501
        if 'telecastids' in params:
            query_params.append(('telecastids', params['telecastids']))  # noqa: E501
            collection_formats['telecastids'] = 'multi'  # noqa: E501
        if 'timeblock' in params:
            query_params.append(('timeblock', params['timeblock']))  # noqa: E501
        if 'timeblocks' in params:
            query_params.append(('timeblocks', params['timeblocks']))  # noqa: E501
            collection_formats['timeblocks'] = 'multi'  # noqa: E501
        if 'tvcategories' in params:
            query_params.append(('tvcategories', params['tvcategories']))  # noqa: E501
            collection_formats['tvcategories'] = 'multi'  # noqa: E501
        if 'tvstations' in params:
            query_params.append(('tvstations', params['tvstations']))  # noqa: E501
            collection_formats['tvstations'] = 'multi'  # noqa: E501
        if 'tvsubcategories' in params:
            query_params.append(('tvsubcategories', params['tvsubcategories']))  # noqa: E501
            collection_formats['tvsubcategories'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/records', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def records_delete_0(self, id, **kwargs):  # noqa: E501
        """Deletes the record with the given identifier.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.records_delete_0(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The identifier of the telecast. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.records_delete_0_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.records_delete_0_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def records_delete_0_with_http_info(self, id, **kwargs):  # noqa: E501
        """Deletes the record with the given identifier.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.records_delete_0_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The identifier of the telecast. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method records_delete_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `records_delete_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/records/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def records_delete_notification(self, id, **kwargs):  # noqa: E501
        """Unsubscribe from a record notification.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.records_delete_notification(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The identifier of the telecast. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.records_delete_notification_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.records_delete_notification_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def records_delete_notification_with_http_info(self, id, **kwargs):  # noqa: E501
        """Unsubscribe from a record notification.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.records_delete_notification_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The identifier of the telecast. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method records_delete_notification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `records_delete_notification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/records/{id}/notification', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def records_delete_resume(self, id, **kwargs):  # noqa: E501
        """Deletes the current stream position used for later resume.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.records_delete_resume(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The record identifier. (required)
        :param bool adfree:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.records_delete_resume_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.records_delete_resume_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def records_delete_resume_with_http_info(self, id, **kwargs):  # noqa: E501
        """Deletes the current stream position used for later resume.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.records_delete_resume_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The record identifier. (required)
        :param bool adfree:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'adfree']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method records_delete_resume" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `records_delete_resume`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'adfree' in params:
            query_params.append(('adfree', params['adfree']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v3/records/{id}/resume', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
